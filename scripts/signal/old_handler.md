## save_original_handler.rbの解説
Rubyの`trap`メソッドを使用して、シグナル処理（signal handling）を設定するコード例です。ここでは、INT（割り込み）シグナルに対するハンドラ（handler、処理方法）を設定し、既存のハンドラを上書きすることなく新しい処理を追加しています。

### コードの解説

1. **最初のハンドラの設定：**
   ```ruby
   trap(:INT) { puts 'This is the first signal handler' }
   ```
   この行は`INT`シグナル（通常はCtrl+Cによって発生）がプログラムに送信された時に実行されるブロック（`{ puts 'This is the first signal handler' }`）を設定しています。このブロックが実行されると、コンソールに`"This is the first signal handler"`が出力されます。

2. **既存のハンドラを保存し、新しいハンドラを設定：**
   ```ruby
   old_handler = trap(:INT) {
     old_handler.call
     puts 'This is the second handler'
     exit
   }
   ```
   この行では、最初に設定したハンドラを`old_handler`変数に保存しています。その後で新しいブロックを`INT`シグナルのために設定しています。新しいブロックでは、まず`old_handler.call`を呼び出して既存のハンドラ（最初に設定したもの）を実行し、その後で新しいメッセージ`"This is the second handler"`を出力してからプログラムを終了します（`exit`）。

### 考慮すべき点
- 上記のコードでは、最初に設定したハンドラが、二つ目のハンドラ設定時に上書きされていますが、`old_handler`に保存された参照を通じて既存のハンドラを呼び出しています。これにより、新旧のハンドラの両方が適切に実行されるようになっています。
- `exit`コマンドを使用しているため、二つ目のハンドラが呼び出されるとプログラムはその時点で終了します。これは、例えば長時間実行するバッチ処理などで、処理を安全に終了させたい場合に有用です。
- このようにシグナルハンドラを設定する際は、シグナルが発生した際の処理の順序や影響を慎重に考慮する必要があります。特に、シグナルハンドラ内で安全でない可能性のある操作（例：外部リソースへのアクセス、重い処理）を避けるべきです。
